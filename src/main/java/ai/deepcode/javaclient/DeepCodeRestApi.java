/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ai.deepcode.javaclient;

import ai.deepcode.javaclient.requests.*;
import ai.deepcode.javaclient.responses.*;
import okhttp3.OkHttpClient;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import retrofit2.Call;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;
import retrofit2.http.*;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.xml.bind.DatatypeConverter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.KeyManagementException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * https://deepcode.freshdesk.com/support/solutions/articles/60000346777-sessions
 * https://deepcode.freshdesk.com/support/solutions/articles/60000357438-bundles
 */
public final class DeepCodeRestApi {

    private DeepCodeRestApi() {
    }

    private static final String API_URL = "https://deeproxy.snyk.io/";

    private static Retrofit retrofit = buildRetrofit(API_URL, false);

    // Create simple REST adapter which points the baseUrl.
    private static Retrofit buildRetrofit(String baseUrl, boolean disableSslVerification) {
        OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .connectTimeout(100, TimeUnit.SECONDS)
                .writeTimeout(100, TimeUnit.SECONDS)
                .readTimeout(100, TimeUnit.SECONDS);
        if (disableSslVerification) {
            X509TrustManager x509TrustManager = buildUnsafeTrustManager();
            final TrustManager[] trustAllCertificates = new TrustManager[]{x509TrustManager};

            try {
                final String sslProtocol = "SSL";
                SSLContext sslContext = SSLContext.getInstance(sslProtocol);
                sslContext.init(null, trustAllCertificates, new SecureRandom());
                SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
                builder.sslSocketFactory(sslSocketFactory, x509TrustManager);
            } catch (NoSuchAlgorithmException | KeyManagementException e) {
                //TODO(pavel): extract Retrofit and OkHttpClient into configuration object to simplify API client building.
                e.printStackTrace();
            }
        }
        OkHttpClient client = builder.build();
        return new Retrofit.Builder()
                .baseUrl(baseUrl)// + "publicapi/")
                .client(client)
                .addConverterFactory(GsonConverterFactory.create())
                .build();
    }

    @NotNull
    private static X509TrustManager buildUnsafeTrustManager() {
        return new X509TrustManager() {
            @Override
            public void checkClientTrusted(X509Certificate[] chain, String authType) {
            }

            @Override
            public void checkServerTrusted(X509Certificate[] chain, String authType) {
            }

            @Override
            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[]{};
            }
        };
    }

    /**
     * Re-set baseUrl for retrofit instance
     *
     * @param baseUrl new baseUrl. <b>Null</b> or empty "" value will reset to default {@code
     *                #API_URL}
     */
    public static void setBaseUrl(@Nullable String baseUrl) {
        setBaseUrl(baseUrl, false);
    }

    public static void setBaseUrl(@Nullable String baseUrl, boolean disableSslVerification) {
        retrofit = buildRetrofit((baseUrl == null || baseUrl.isEmpty()) ? API_URL : baseUrl, disableSslVerification);
    }

    private interface CreateBundleCall {

        @retrofit2.http.Headers("Content-Type: application/json")
        @POST("bundle")
        Call<CreateBundleResponse> doCreateBundle(
                @Header("Session-Token") String token, @Body Map files);
    }

    private static <Req> CreateBundleResponse doCreateBundle(String token, Req request) {
        CreateBundleCall createBundleCall = retrofit.create(CreateBundleCall.class);
        Response<CreateBundleResponse> retrofitResponse;
        try {
            if (request instanceof Map) {
                retrofitResponse =
                        createBundleCall.doCreateBundle(token, (Map) request).execute();
            } else {
                throw new IllegalArgumentException();
            }
        } catch (IOException e) {
            return new CreateBundleResponse();
        }
        CreateBundleResponse result = retrofitResponse.body();
        if (result == null) {
            result = new CreateBundleResponse();
        }
        result.setStatusCode(retrofitResponse.code());
        switch (retrofitResponse.code()) {
            case 200:
                result.setStatusDescription("The bundle creation was successful");
                break;
            case 400:
                result.setStatusDescription("Request content doesn't match the specifications");
                break;
            case 401:
                result.setStatusDescription("Missing sessionToken or incomplete login process");
                break;
            case 403:
                result.setStatusDescription("Unauthorized access to requested repository");
                break;
            case 404:
                result.setStatusDescription("Unable to resolve requested oid");
                break;
            default:
                result.setStatusDescription("Unknown Status Code: " + retrofitResponse.code());
                break;
        }
        return result;
    }

    /**
     * Creates a new bundle with direct file(s) source at {@link FileContent}.
     *
     * @return {@link CreateBundleResponse} instance
     */
    @NotNull
    public static CreateBundleResponse createBundle(String token, FileContentRequest files) {
        try {
            Map<String, FileHash2ContentRequest> req = new HashMap<>(files.getFiles().size());
            for (FileContent file : files.getFiles()) {
                MessageDigest digest = MessageDigest.getInstance("SHA-256");
                byte[] sha = digest.digest(file.getFileContent().getBytes(StandardCharsets.UTF_8));
                String hash = DatatypeConverter.printHexBinary(sha).toLowerCase();
                FileHash2ContentRequest hash2Content = new FileHash2ContentRequest(hash, file.getFileContent());
                req.put(file.getFilePath(), hash2Content);
            }
            return doCreateBundle(token, req);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Creates a new bundle for file(s) with Hash.
     *
     * @return {@link CreateBundleResponse} instance
     */
    @NotNull
    public static CreateBundleResponse createBundle(String token, FileHashRequest files) {
        return doCreateBundle(token, files.getFiles());
    }

    private interface CheckBundleCall {
        //    @retrofit2.http.Headers("Content-Type: application/json")
        @GET("bundle/{bundleId}")
        Call<CreateBundleResponse> doCheckBundle(
                @Header("Session-Token") String token,
                @Path(value = "bundleId", encoded = true) String bundleId);
    }

    /**
     * Checks the status of a bundle.
     *
     * @param bundleId the parent bundle to extend
     * @return {@link CreateBundleResponse} instance
     */
    @NotNull
    public static CreateBundleResponse checkBundle(
            String token, String bundleId) {
        CheckBundleCall checkBundleCall = retrofit.create(CheckBundleCall.class);
        Response<CreateBundleResponse> retrofitResponse;
        try {
            retrofitResponse =
                    checkBundleCall.doCheckBundle(token, bundleId).execute();
        } catch (IOException e) {
            return new CreateBundleResponse();
        }
        CreateBundleResponse result = retrofitResponse.body();
        if (result == null) {
            result = new CreateBundleResponse();
        }
        result.setStatusCode(retrofitResponse.code());
        switch (retrofitResponse.code()) {
            case 200:
                result.setStatusDescription("The bundle checked successfully");
                break;
            case 401:
                result.setStatusDescription("Missing sessionToken or incomplete login process");
                break;
            case 403:
                result.setStatusDescription("Unauthorized access to parent bundle");
                break;
            case 404:
                result.setStatusDescription("Uploaded bundle has expired");
                break;
            default:
                result.setStatusDescription("Unknown Status Code: " + retrofitResponse.code());
                break;
        }
        return result;
    }

    private interface ExtendBundleCall {
        @retrofit2.http.Headers("Content-Type: application/json")
        @PUT("bundle/{bundleId}")
        Call<CreateBundleResponse> doExtendBundle(
                @Header("Session-Token") String token,
                @Path(value = "bundleId", encoded = true) String bundleId,
                @Body ExtendBundleWithContentRequest extendBundleRequest);

        @retrofit2.http.Headers("Content-Type: application/json")
        @PUT("bundle/{bundleId}")
        Call<CreateBundleResponse> doExtendBundle(
                @Header("Session-Token") String token,
                @Path(value = "bundleId", encoded = true) String bundleId,
                @Body ExtendBundleRequest extendBundleRequest);
    }

    /**
     * Creates a new bundle by extending a previously uploaded one.
     *
     * @param bundleId the parent bundle to extend
     * @return {@link CreateBundleResponse} instance
     */
    @NotNull
    public static CreateBundleResponse extendBundle(
            String token, String bundleId, IExtendBundleRequest extendBundleRequest) {
        ExtendBundleCall extendBundleCall = retrofit.create(ExtendBundleCall.class);
        Response<CreateBundleResponse> retrofitResponse;
        try {
            if (extendBundleRequest instanceof ExtendBundleWithContentRequest) {
                retrofitResponse =
                        extendBundleCall.doExtendBundle(token, bundleId, (ExtendBundleWithContentRequest) extendBundleRequest).execute();

            } else if (extendBundleRequest instanceof ExtendBundleRequest) {
                retrofitResponse =
                        extendBundleCall.doExtendBundle(token, bundleId, (ExtendBundleWithContentRequest) extendBundleRequest).execute();
            } else throw new IllegalArgumentException("Cannot process " + extendBundleRequest.getClass().getName());
        } catch (IOException e) {
            return new CreateBundleResponse();
        }
        CreateBundleResponse result = retrofitResponse.body();
        if (result == null) {
            result = new CreateBundleResponse();
        }
        result.setStatusCode(retrofitResponse.code());
        switch (retrofitResponse.code()) {
            case 200:
                result.setStatusDescription("The bundle extension was successful");
                break;
            case 400:
                result.setStatusDescription("Attempted to extend a git bundle, or ended up with an empty bundle after the extension");
                break;
            case 401:
                result.setStatusDescription("Missing sessionToken or incomplete login process");
                break;
            case 403:
                result.setStatusDescription("Unauthorized access to parent bundle");
                break;
            case 404:
                result.setStatusDescription("Parent bundle has expired");
                break;
            case 413:
                result.setStatusDescription("Payload too large");
                break;
            default:
                result.setStatusDescription("Unknown Status Code: " + retrofitResponse.code());
                break;
        }
        return result;
    }

    private interface GetAnalysisCall {
        @retrofit2.http.Headers("Content-Type: application/json")
        @POST("analysis")
        Call<GetAnalysisResponse> doGetAnalysis(
                @Header("Session-Token") String token,
                @Body GetAnalysisRequest filesToAnalyse);
    }

    /**
     * Starts a new bundle analysis or checks its current status and available results.
     *
     * @return {@link GetAnalysisResponse} instance
     */
    @NotNull
    public static GetAnalysisResponse getAnalysis(String token, String bundleHash, Integer severity) {
        return getAnalysis(token, bundleHash, severity, Collections.emptyList());
    }

    /**
     * Starts a new bundle analysis or checks its current status and available results.
     *
     * @return {@link GetAnalysisResponse} instance
     */
    @NotNull
    public static GetAnalysisResponse getAnalysis(
            String token,
            String bundleHash,
            Integer severity,
            List<String> limitToFiles) {

        GetAnalysisCall getAnalysisCall = retrofit.create(GetAnalysisCall.class);
        try {
            Response<GetAnalysisResponse> retrofitResponse =
                    getAnalysisCall
                            .doGetAnalysis(
                                    token,
                                    new GetAnalysisRequest(
                                            new GetAnalysisRequestKey(
                                                    bundleHash, limitToFiles.toArray(new String[0])
                                            ),
                                            severity,
                                            true))
                            .execute();
            GetAnalysisResponse result = retrofitResponse.body();
            if (result == null) result = new GetAnalysisResponse();
            result.setStatusCode(retrofitResponse.code());
            switch (retrofitResponse.code()) {
                case 200:
                    result.setStatusDescription("The analysis request was successful");
                    break;
                case 401:
                    result.setStatusDescription("Missing sessionToken or incomplete login process");
                    break;
                case 403:
                    result.setStatusDescription("Unauthorized access to requested repository");
                    break;
                default:
                    result.setStatusDescription("Unknown Status Code: " + retrofitResponse.code());
                    break;
            }
            return result;
        } catch (IOException e) {
            return new GetAnalysisResponse();
        }
    }

    private interface GetFiltersCall {
        @GET("filters")
        Call<GetFiltersResponse> doGetFilters(@Header("Session-Token") String token);
    }

    /**
     * Requests current filtering options for uploaded bundles.
     *
     * @return {@link GetFiltersResponse} instance}
     */
    @NotNull
    public static GetFiltersResponse getFilters(String token) {
        GetFiltersCall getFiltersCall = retrofit.create(GetFiltersCall.class);
        try {
            Response<GetFiltersResponse> retrofitResponse = getFiltersCall.doGetFilters(token).execute();
            GetFiltersResponse result = retrofitResponse.body();
            if (result == null) result = new GetFiltersResponse();
            result.setStatusCode(retrofitResponse.code());
            switch (retrofitResponse.code()) {
                case 200:
                    result.setStatusDescription("The filters request was successful");
                    break;
                case 401:
                    result.setStatusDescription("Missing sessionToken or incomplete login process");
                    break;
                default:
                    result.setStatusDescription("Unknown Status Code: " + retrofitResponse.code());
                    break;
            }
            return result;
        } catch (IOException e) {
            return new GetFiltersResponse();
        }
    }
}
